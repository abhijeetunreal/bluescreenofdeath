<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Boids - Morphological Evolution</title>
    <style>
        :root {
            --bg-color: #020617;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
        }

        body, html {
            width: 100%;
            height: 100%;
            background-color: var(--bg-color);
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            display: block;
        }

        #container::after {
            content: "";
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 30%, rgba(0,0,0,0.4) 100%);
            pointer-events: none;
            z-index: 5;
        }
    </style>
</head>
<body>

    <div id="container">
        <canvas id="boidCanvas"></canvas>
    </div>

    <script>
        class Vector {
            constructor(x, y) {
                this.x = x || 0;
                this.y = y || 0;
            }
            add(v) { this.x += v.x; this.y += v.y; return this; }
            sub(v) { this.x -= v.x; this.y -= v.y; return this; }
            mult(n) { this.x *= n; this.y *= n; return this; }
            div(n) { this.x /= n; this.y /= n; return this; }
            magSq() { return this.x * this.x + this.y * this.y; }
            mag() { return Math.sqrt(this.magSq()); }
            normalize() { const m = this.mag(); if (m !== 0) this.div(m); return this; }
            limit(max) { if (this.magSq() > max * max) { this.normalize(); this.mult(max); } return this; }
            setMag(n) { return this.normalize().mult(n); }
            static distSq(v1, v2) { return (v1.x - v2.x)**2 + (v1.y - v2.y)**2; }
            static sub(v1, v2) { return new Vector(v1.x - v2.x, v1.y - v2.y); }
        }

        class Grid {
            constructor(width, height, cellSize) {
                this.cellSize = cellSize;
                this.cols = Math.ceil(width / cellSize);
                this.rows = Math.ceil(height / cellSize);
                this.cells = new Array(this.cols * this.rows).fill(0).map(() => []);
            }
            clear() { for (let i = 0; i < this.cells.length; i++) this.cells[i].length = 0; }
            add(item) {
                const col = Math.floor(item.pos.x / this.cellSize);
                const row = Math.floor(item.pos.y / this.cellSize);
                if (col >= 0 && col < this.cols && row >= 0 && row < this.rows) {
                    this.cells[col + row * this.cols].push(item);
                }
            }
            getNearby(pos, radius) {
                const col = Math.floor(pos.x / this.cellSize);
                const row = Math.floor(pos.y / this.cellSize);
                const nearby = [];
                const range = Math.ceil(radius / this.cellSize);
                for (let i = -range; i <= range; i++) {
                    for (let j = -range; j <= range; j++) {
                        const c = col + i; const r = row + j;
                        if (c >= 0 && c < this.cols && r >= 0 && r < this.rows) {
                            nearby.push(...this.cells[c + r * this.cols]);
                        }
                    }
                }
                return nearby;
            }
        }

        const canvas = document.getElementById('boidCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });

        let width, height;
        let boids = [];
        let predator, guardian, spatialGrid;

        const BOID_COUNT = 200;
        const MUTATION_RATE = 0.15;

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            spatialGrid = new Grid(width, height, 60);
            initSimulation();
        }

        window.addEventListener('resize', resize);

        class Predator {
            constructor() {
                this.pos = new Vector(width / 4, height / 4);
                this.vel = new Vector(Math.random() * 2 - 1, Math.random() * 2 - 1).setMag(2);
                this.acc = new Vector(0, 0);
                this.size = 12;
            }
            update(threat) {
                const nearby = spatialGrid.getNearby(this.pos, 200);
                let closest = null;
                let closestDistSq = Infinity;
                for (let b of nearby) {
                    const dSq = Vector.distSq(this.pos, b.pos);
                    if (dSq < closestDistSq) { closestDistSq = dSq; closest = b; }
                }
                if (closest) {
                    let steer = Vector.sub(closest.pos, this.pos).setMag(4).sub(this.vel).limit(0.12);
                    this.acc.add(steer);
                    if (closestDistSq < (this.size + closest.dna.size)**2) { 
                        boids.splice(boids.indexOf(closest), 1);
                        spawnBoid(true); 
                    }
                }
                if (Vector.distSq(this.pos, threat.pos) < 22500) {
                    let flee = Vector.sub(this.pos, threat.pos).setMag(6).sub(this.vel).limit(0.25);
                    this.acc.add(flee.mult(2.5));
                }
                this.pos.add(this.vel.add(this.acc).limit(4.2));
                this.acc.mult(0);
                this.edges();
            }
            edges() {
                if (this.pos.x > width) this.pos.x = 0; else if (this.pos.x < 0) this.pos.x = width;
                if (this.pos.y > height) this.pos.y = 0; else if (this.pos.y < 0) this.pos.y = height;
            }
            draw() {
                ctx.save();
                ctx.translate(this.pos.x, this.pos.y);
                ctx.rotate(Math.atan2(this.vel.y, this.vel.x));
                ctx.fillStyle = '#ef4444';
                ctx.beginPath();
                ctx.moveTo(this.size * 2, 0); ctx.lineTo(-this.size, -this.size); ctx.lineTo(-this.size, this.size);
                ctx.fill();
                ctx.restore();
            }
        }

        class Guardian {
            constructor() {
                this.pos = new Vector(width * 0.75, height * 0.75);
                this.vel = new Vector(Math.random() * 2 - 1, Math.random() * 2 - 1).setMag(2);
                this.acc = new Vector(0, 0);
                this.size = 10;
            }
            update(enemy) {
                let steer = Vector.sub(enemy.pos, this.pos).setMag(3).sub(this.vel).limit(0.06);
                this.acc.add(steer);
                this.pos.add(this.vel.add(this.acc).limit(3.2));
                this.acc.mult(0);
                this.edges();
            }
            edges() {
                if (this.pos.x > width) this.pos.x = 0; else if (this.pos.x < 0) this.pos.x = width;
                if (this.pos.y > height) this.pos.y = 0; else if (this.pos.y < 0) this.pos.y = height;
            }
            draw() {
                ctx.save();
                ctx.translate(this.pos.x, this.pos.y);
                ctx.rotate(Math.atan2(this.vel.y, this.vel.x));
                ctx.fillStyle = '#22c55e';
                ctx.beginPath();
                ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        class Boid {
            constructor(genes) {
                this.pos = new Vector(Math.random() * width, Math.random() * height);
                this.vel = new Vector(Math.random() * 2 - 1, Math.random() * 2 - 1).setMag(2);
                this.acc = new Vector(0, 0);
                
                // Genetic Logic
                this.dna = genes || {
                    sep: Math.random() * 2,
                    ali: Math.random() * 2,
                    coh: Math.random() * 2,
                    perception: 40 + Math.random() * 80,
                    maxSpeed: 2.5 + Math.random() * 3,
                    maxForce: 0.03 + Math.random() * 0.1,
                    size: 2 + Math.random() * 5,
                    shape: Math.floor(Math.random() * 4) // 0: Triangle, 1: Circle, 2: Square, 3: Diamond
                };
            }

            flock(hunter, protector) {
                let sep = new Vector(0,0), ali = new Vector(0,0), coh = new Vector(0,0);
                let total = 0;

                const nearby = spatialGrid.getNearby(this.pos, this.dna.perception);
                for (let other of nearby) {
                    let dSq = Vector.distSq(this.pos, other.pos);
                    if (other !== this && dSq < this.dna.perception * this.dna.perception) {
                        ali.add(other.vel);
                        coh.add(other.pos);
                        sep.add(Vector.sub(this.pos, other.pos).div(dSq || 1));
                        total++;
                    }
                }

                if (total > 0) {
                    this.acc.add(ali.div(total).setMag(this.dna.maxSpeed).sub(this.vel).limit(this.dna.maxForce).mult(this.dna.ali));
                    this.acc.add(coh.div(total).sub(this.pos).setMag(this.dna.maxSpeed).sub(this.vel).limit(this.dna.maxForce).mult(this.dna.coh));
                    this.acc.add(sep.div(total).setMag(this.dna.maxSpeed).sub(this.vel).limit(this.dna.maxForce).mult(this.dna.sep * 1.5));
                }

                if (Vector.distSq(this.pos, hunter.pos) < 16900) {
                    this.acc.add(Vector.sub(this.pos, hunter.pos).setMag(this.dna.maxSpeed * 1.6).limit(this.dna.maxForce * 4));
                }
                if (Vector.distSq(this.pos, protector.pos) < 25600) {
                    this.acc.add(Vector.sub(protector.pos, this.pos).setMag(this.dna.maxSpeed).limit(this.dna.maxForce));
                }
            }

            update() {
                this.pos.add(this.vel.add(this.acc).limit(this.dna.maxSpeed));
                this.acc.mult(0);
                if (this.pos.x > width) this.pos.x = 0; else if (this.pos.x < 0) this.pos.x = width;
                if (this.pos.y > height) this.pos.y = 0; else if (this.pos.y < 0) this.pos.y = height;
            }

            draw() {
                const r = Math.floor((this.dna.maxSpeed / 5.5) * 255);
                const b = Math.floor((this.dna.coh / 2) * 255);
                const g = Math.floor((this.dna.sep / 2) * 255);
                
                ctx.save();
                ctx.translate(this.pos.x, this.pos.y);
                ctx.rotate(Math.atan2(this.vel.y, this.vel.x));
                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                
                const s = this.dna.size;
                switch(this.dna.shape) {
                    case 0: // Triangle
                        ctx.beginPath();
                        ctx.moveTo(s * 1.5, 0); ctx.lineTo(-s, -s); ctx.lineTo(-s, s);
                        ctx.fill();
                        break;
                    case 1: // Circle
                        ctx.beginPath();
                        ctx.arc(0, 0, s, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    case 2: // Square
                        ctx.fillRect(-s/2, -s/2, s, s);
                        break;
                    case 3: // Diamond
                        ctx.beginPath();
                        ctx.moveTo(s, 0); ctx.lineTo(0, s); ctx.lineTo(-s, 0); ctx.lineTo(0, -s);
                        ctx.fill();
                        break;
                }
                ctx.restore();
            }
        }

        function spawnBoid(mutate = false) {
            let genes = null;
            if (mutate && boids.length > 0) {
                const parent = boids[Math.floor(Math.random() * boids.length)];
                genes = { ...parent.dna };
                for (let key in genes) {
                    if (Math.random() < MUTATION_RATE) {
                        if (key === 'shape') {
                            genes[key] = Math.floor(Math.random() * 4);
                        } else {
                            genes[key] += (Math.random() - 0.5) * (genes[key] * 0.25);
                        }
                    }
                }
            }
            boids.push(new Boid(genes));
        }

        function initSimulation() {
            boids = [];
            for (let i = 0; i < BOID_COUNT; i++) spawnBoid();
            predator = new Predator();
            guardian = new Guardian();
        }

        function animate() {
            ctx.fillStyle = '#02061725';
            ctx.fillRect(0, 0, width, height);

            spatialGrid.clear();
            for (let b of boids) spatialGrid.add(b);

            guardian.update(predator);
            guardian.draw();
            predator.update(guardian);
            predator.draw();

            for (let b of boids) {
                b.flock(predator, guardian);
                b.update();
                b.draw();
            }

            requestAnimationFrame(animate);
        }

        resize();
        animate();
    </script>
</body>
</html>

