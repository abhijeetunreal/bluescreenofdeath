<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Pro - AI & Multiplayer Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --board-light: #e2e8f0;
            --board-dark: #94a3b8;
            --highlight: rgba(74, 222, 128, 0.5);
            --selected: rgba(96, 165, 250, 0.6);
            --last-move: rgba(250, 204, 21, 0.3);
        }

        body {
            background-color: #0f172a;
            color: #f8fafc;
            user-select: none;
            transition: all 0.5s ease;
        }

        /* Immersive Mode Overrides */
        body.cvc-mode {
            padding: 0 !important;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }

        body.cvc-mode header,
        body.cvc-mode aside,
        body.cvc-mode .lg\:flex,
        body.cvc-mode .bg-slate-800\/50,
        body.cvc-mode .flex.justify-between.w-full.mt-6,
        body.cvc-mode #mode-selector-container {
            display: none !important;
        }

        body.cvc-mode main {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100vw;
            height: 100vh;
            max-width: none;
        }

        body.cvc-mode .chess-board {
            max-width: 90vh;
            max-height: 90vh;
            width: 90vmin;
            height: 90vmin;
        }

        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            aspect-ratio: 1 / 1;
            width: 100%;
            max-width: 600px;
            border: 4px solid #334155;
            border-radius: 4px;
            overflow: hidden;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
        }

        .square {
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            cursor: pointer;
            transition: background-color 0.15s ease;
        }

        .square.light { background-color: var(--board-light); }
        .square.dark { background-color: var(--board-dark); }
        
        .square.selected { background-color: var(--selected) !important; }
        .square.highlighted::after {
            content: "";
            width: 25%;
            height: 25%;
            background-color: var(--highlight);
            border-radius: 50%;
        }
        
        .square.last-move { background-color: var(--last-move) !important; }

        .piece {
            font-size: 2.5rem;
            z-index: 10;
            transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        body.cvc-mode .piece {
            font-size: 6vmin;
        }

        .piece.white { color: #ffffff; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.4)); }
        .piece.black { color: #000000; filter: drop-shadow(0 2px 2px rgba(255,255,255,0.2)); }

        @media (max-width: 640px) {
            .piece { font-size: 1.8rem; }
        }

        .history-item:nth-child(even) { background-color: rgba(255,255,255,0.05); }

        .btn-mode.active {
            background-color: #3b82f6;
            color: white;
            border-color: #3b82f6;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center py-8 px-4">

    <!-- Header -->
    <header class="text-center mb-6">
        <h1 class="text-4xl font-extrabold tracking-tight mb-4 text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-emerald-400">
            CHESS PRO
        </h1>
        
        <!-- Mode Selector -->
        <div id="mode-selector-container" class="flex flex-wrap justify-center gap-2 mb-4">
            <button onclick="setMode('pvp')" id="mode-pvp" class="btn-mode px-4 py-2 rounded-lg bg-slate-800 border border-slate-700 text-xs font-bold uppercase tracking-widest transition-all active">Player vs Player</button>
            <button onclick="setMode('pvc')" id="mode-pvc" class="btn-mode px-4 py-2 rounded-lg bg-slate-800 border border-slate-700 text-xs font-bold uppercase tracking-widest transition-all">Player vs CPU</button>
            <button onclick="setMode('cvc')" id="mode-cvc" class="btn-mode px-4 py-2 rounded-lg bg-slate-800 border border-slate-700 text-xs font-bold uppercase tracking-widest transition-all">CPU vs CPU</button>
        </div>

        <div id="turn-indicator" class="inline-block px-6 py-2 rounded-full bg-white text-slate-900 text-sm font-bold uppercase tracking-widest">
            White's Turn
        </div>
    </header>

    <!-- Main Game Container -->
    <main class="w-full max-w-6xl grid grid-cols-1 lg:grid-cols-3 gap-8 items-start">
        
        <!-- Left Column: Capture Info (Desktop) -->
        <div class="hidden lg:flex flex-col gap-4">
            <div class="bg-slate-800/50 p-4 rounded-xl border border-slate-700">
                <h3 class="text-xs font-bold uppercase text-slate-400 mb-3">Captured Pieces</h3>
                <div id="captured-white" class="flex flex-wrap gap-2 text-2xl min-h-[40px]"></div>
                <div id="captured-black" class="flex flex-wrap gap-2 text-2xl mt-4 min-h-[40px]"></div>
            </div>
            <div id="ai-status" class="text-xs text-slate-500 font-mono italic px-2 hidden">AI is thinking...</div>
        </div>

        <!-- Middle Column: The Board -->
        <div class="flex flex-col items-center middle-col">
            <div id="board" class="chess-board"></div>
            
            <div class="flex justify-between w-full mt-6 gap-4">
                <button id="reset-btn" class="flex-1 bg-slate-800 hover:bg-slate-700 text-white font-bold py-3 px-6 rounded-lg transition-colors border border-slate-700">
                    <i class="fas fa-rotate-left mr-2"></i> New Game
                </button>
                <button id="undo-btn" class="flex-1 bg-slate-800 hover:bg-slate-700 text-white font-bold py-3 px-6 rounded-lg transition-colors border border-slate-700">
                    <i class="fas fa-undo mr-2"></i> Undo
                </button>
            </div>
        </div>

        <!-- Right Column: Move History -->
        <div class="bg-slate-800/50 rounded-xl border border-slate-700 flex flex-col h-[400px] lg:h-[600px] w-full">
            <div class="p-4 border-b border-slate-700 flex justify-between items-center">
                <h3 class="text-sm font-bold uppercase text-slate-400">Move History</h3>
                <span id="move-count" class="text-xs bg-slate-700 px-2 py-0.5 rounded text-slate-300">0 Moves</span>
            </div>
            <div id="history-log" class="flex-1 overflow-y-auto p-2 font-mono text-sm">
                <!-- Moves injected here -->
            </div>
        </div>
    </main>

    <!-- Victory Modal -->
    <div id="victory-modal" class="fixed inset-0 bg-blue-900/40 backdrop-blur-sm hidden z-50 flex items-center justify-center p-4">
        <div class="bg-slate-900 border-2 border-emerald-500 p-10 rounded-3xl text-center shadow-2xl transform scale-110">
            <div class="text-emerald-400 text-6xl mb-4"><i class="fas fa-crown"></i></div>
            <h2 id="winner-text" class="text-4xl font-black mb-2 uppercase tracking-tighter text-white">WHITE WINS!</h2>
            <p class="text-slate-400 mb-8">Checkmate achieved.</p>
            <button onclick="location.reload()" class="bg-emerald-500 hover:bg-emerald-600 text-white font-black py-3 px-10 rounded-full transition-all uppercase tracking-widest">
                Play Again
            </button>
        </div>
    </div>

    <script>
        const boardEl = document.getElementById('board');
        const turnIndicator = document.getElementById('turn-indicator');
        const historyLog = document.getElementById('history-log');
        const resetBtn = document.getElementById('reset-btn');
        const undoBtn = document.getElementById('undo-btn');
        const victoryModal = document.getElementById('victory-modal');
        const winnerText = document.getElementById('winner-text');
        const moveCountLabel = document.getElementById('move-count');
        const aiStatus = document.getElementById('ai-status');

        const PIECES = {
            white: {
                king: 'fa-chess-king', queen: 'fa-chess-queen', rook: 'fa-chess-rook',
                bishop: 'fa-chess-bishop', knight: 'fa-chess-knight', pawn: 'fa-chess-pawn'
            },
            black: {
                king: 'fa-chess-king', queen: 'fa-chess-queen', rook: 'fa-chess-rook',
                bishop: 'fa-chess-bishop', knight: 'fa-chess-knight', pawn: 'fa-chess-pawn'
            }
        };

        const PIECE_VALUES = { pawn: 10, knight: 30, bishop: 30, rook: 50, queen: 90, king: 900 };

        let board = [];
        let selectedSquare = null;
        let validMoves = [];
        let turn = 'white';
        let moveHistory = [];
        let captured = { white: [], black: [] };
        let gameMode = 'pvp'; 
        let isThinking = false;

        function setMode(mode) {
            if (moveHistory.length > 0 && mode !== gameMode && !confirm("Switching modes will restart the game. Continue?")) return;
            gameMode = mode;
            document.querySelectorAll('.btn-mode').forEach(b => b.classList.remove('active'));
            document.getElementById(`mode-${mode}`).classList.add('active');
            
            if (mode === 'cvc') {
                document.body.classList.add('cvc-mode');
            } else {
                document.body.classList.remove('cvc-mode');
            }
            
            localStorage.setItem('chessMode', mode);
            resetGameInternal();
        }

        function resetGameInternal() {
            createBoard();
            moveHistory = [];
            captured = { white: [], black: [] };
            historyLog.innerHTML = '';
            turn = 'white';
            renderBoard();
            if (gameMode === 'cvc') setTimeout(handleAITurn, 1000);
        }

        // Init
        if (localStorage.getItem('chessMode')) {
            gameMode = localStorage.getItem('chessMode');
            document.querySelectorAll('.btn-mode').forEach(b => b.classList.remove('active'));
            document.getElementById(`mode-${gameMode}`).classList.add('active');
            if (gameMode === 'cvc') document.body.classList.add('cvc-mode');
        }

        function createBoard() {
            board = Array(8).fill(null).map(() => Array(8).fill(null));
            const layout = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];
            for (let i = 0; i < 8; i++) {
                board[0][i] = { type: layout[i], color: 'black', moved: false };
                board[1][i] = { type: 'pawn', color: 'black', moved: false };
                board[6][i] = { type: 'pawn', color: 'white', moved: false };
                board[7][i] = { type: layout[i], color: 'white', moved: false };
            }
        }

        function renderBoard() {
            boardEl.innerHTML = '';
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const square = document.createElement('div');
                    square.classList.add('square');
                    square.classList.add((r + c) % 2 === 0 ? 'light' : 'dark');
                    
                    const piece = board[r][c];
                    if (piece) {
                        const pieceIcon = document.createElement('i');
                        pieceIcon.classList.add('fas', PIECES[piece.color][piece.type], 'piece', piece.color);
                        square.appendChild(pieceIcon);
                    }

                    if (selectedSquare && selectedSquare.r === r && selectedSquare.c === c) square.classList.add('selected');
                    if (validMoves.some(m => m.r === r && m.c === c)) square.classList.add('highlighted');

                    if (moveHistory.length > 0) {
                        const last = moveHistory[moveHistory.length - 1];
                        if ((last.from.r === r && last.from.c === c) || (last.to.r === r && last.to.c === c)) square.classList.add('last-move');
                    }

                    square.onclick = () => {
                        if (isThinking || gameMode === 'cvc' || (gameMode === 'pvc' && turn === 'black')) return;
                        handleSquareClick(r, c);
                    };
                    boardEl.appendChild(square);
                }
            }
            updateUI();
        }

        function updateUI() {
            if (gameMode !== 'cvc') {
                turnIndicator.innerText = `${turn.charAt(0).toUpperCase() + turn.slice(1)}'s Turn`;
                turnIndicator.className = `inline-block px-6 py-2 rounded-full text-sm font-bold uppercase tracking-widest ${turn === 'white' ? 'bg-white text-slate-900' : 'bg-slate-900 text-white'}`;
                document.getElementById('captured-white').innerHTML = captured.white.map(p => `<i class="fas ${PIECES.black[p]} text-slate-400"></i>`).join('');
                document.getElementById('captured-black').innerHTML = captured.black.map(p => `<i class="fas ${PIECES.white[p]} text-white"></i>`).join('');
                moveCountLabel.innerText = `${moveHistory.length} Moves`;
            }
        }

        function handleSquareClick(r, c) {
            const clickedPiece = board[r][c];
            if (clickedPiece && clickedPiece.color === turn) {
                selectedSquare = { r, c };
                validMoves = getValidMoves(r, c);
                renderBoard();
                return;
            }
            if (selectedSquare && validMoves.some(m => m.r === r && m.c === c)) {
                executeMove(selectedSquare.r, selectedSquare.c, r, c);
                selectedSquare = null;
                validMoves = [];
                renderBoard();
                return;
            }
            selectedSquare = null;
            validMoves = [];
            renderBoard();
        }

        function getValidMoves(r, c, ignoreCheck = false) {
            const piece = board[r][c];
            if (!piece) return [];
            let moves = [];
            const dr = [-1, 1, 0, 0, -1, -1, 1, 1], dc = [0, 0, -1, 1, -1, 1, -1, 1];

            switch (piece.type) {
                case 'pawn':
                    const dir = piece.color === 'white' ? -1 : 1;
                    if (isInside(r + dir, c) && !board[r + dir][c]) {
                        moves.push({ r: r + dir, c });
                        if (!piece.moved && isInside(r + 2 * dir, c) && !board[r + 2 * dir][c]) moves.push({ r: r + 2 * dir, c });
                    }
                    for (let side of [-1, 1]) {
                        if (isInside(r + dir, c + side)) {
                            const target = board[r + dir][c + side];
                            if (target && target.color !== piece.color) moves.push({ r: r + dir, c: c + side });
                        }
                    }
                    break;
                case 'rook': for (let i = 0; i < 4; i++) moves = moves.concat(getSlidingMoves(r, c, dr[i], dc[i], piece.color)); break;
                case 'bishop': for (let i = 4; i < 8; i++) moves = moves.concat(getSlidingMoves(r, c, dr[i], dc[i], piece.color)); break;
                case 'queen': for (let i = 0; i < 8; i++) moves = moves.concat(getSlidingMoves(r, c, dr[i], dc[i], piece.color)); break;
                case 'knight':
                    const kr = [-2, -2, -1, -1, 1, 1, 2, 2], kc = [-1, 1, -2, 2, -2, 2, -1, 1];
                    for (let i = 0; i < 8; i++) {
                        const nr = r + kr[i], nc = c + kc[i];
                        if (isInside(nr, nc)) {
                            const t = board[nr][nc];
                            if (!t || t.color !== piece.color) moves.push({ r: nr, c: nc });
                        }
                    }
                    break;
                case 'king':
                    for (let i = 0; i < 8; i++) {
                        const nr = r + dr[i], nc = c + dc[i];
                        if (isInside(nr, nc)) {
                            const t = board[nr][nc];
                            if (!t || t.color !== piece.color) moves.push({ r: nr, c: nc });
                        }
                    }
                    break;
            }
            return ignoreCheck ? moves : moves.filter(m => !wouldResultInCheck(r, c, m.r, m.c, piece.color));
        }

        function getSlidingMoves(r, c, dr, dc, color) {
            const moves = [];
            let nr = r + dr, nc = c + dc;
            while (isInside(nr, nc)) {
                const target = board[nr][nc];
                if (!target) moves.push({ r: nr, c: nc });
                else { if (target.color !== color) moves.push({ r: nr, c: nc }); break; }
                nr += dr; nc += dc;
            }
            return moves;
        }

        function isInside(r, c) { return r >= 0 && r < 8 && c >= 0 && c < 8; }

        function executeMove(fromR, fromC, toR, toC) {
            const piece = board[fromR][fromC];
            const target = board[toR][toC];
            if (target) {
                captured[turn].push(target.type);
                if (target.type === 'king') {
                    showVictory(turn);
                    return;
                }
            }
            moveHistory.push({ from: { r: fromR, c: fromC }, to: { r: toR, c: toC }, piece: { ...piece }, captured: target ? { ...target } : null, prevMoved: piece.moved });
            board[toR][toC] = piece;
            board[fromR][fromC] = null;
            piece.moved = true;
            if (piece.type === 'pawn' && (toR === 0 || toR === 7)) piece.type = 'queen';
            
            if (gameMode !== 'cvc') addToHistoryLog(piece, fromR, fromC, toR, toC, target);
            
            turn = turn === 'white' ? 'black' : 'white';
            
            checkGameStatus();
            if (victoryModal.classList.contains('hidden')) {
                setTimeout(handleAITurn, 300);
            }
        }

        function checkGameStatus() {
            let hasMoves = false;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (board[r][c] && board[r][c].color === turn) {
                        if (getValidMoves(r, c).length > 0) { hasMoves = true; break; }
                    }
                }
                if (hasMoves) break;
            }
            if (!hasMoves) {
                const kingInCheck = isKingInCheck(turn);
                if (kingInCheck) showVictory(turn === 'white' ? 'black' : 'white');
                else {
                    if (gameMode === 'cvc') setTimeout(resetGameInternal, 3000);
                    else alert("Stalemate!");
                }
            }
        }

        function isKingInCheck(color) {
            let kingPos = null;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (board[r][c] && board[r][c].type === 'king' && board[r][c].color === color) kingPos = { r, c };
                }
            }
            if (!kingPos) return false;
            const opp = color === 'white' ? 'black' : 'white';
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (board[r][c] && board[r][c].color === opp) {
                        if (getValidMoves(r, c, true).some(m => m.r === kingPos.r && m.c === kingPos.c)) return true;
                    }
                }
            }
            return false;
        }

        function handleAITurn() {
            if (!victoryModal.classList.contains('hidden')) return;
            const isAIWhite = gameMode === 'cvc';
            const isAIBlack = gameMode === 'cvc' || gameMode === 'pvc';
            if ((turn === 'white' && isAIWhite) || (turn === 'black' && isAIBlack)) {
                isThinking = true;
                if (gameMode !== 'cvc') aiStatus.classList.remove('hidden');
                setTimeout(() => {
                    const bestMove = getBestMove(turn);
                    if (bestMove) executeMove(bestMove.from.r, bestMove.from.c, bestMove.to.r, bestMove.to.c);
                    isThinking = false;
                    if (gameMode !== 'cvc') aiStatus.classList.add('hidden');
                    renderBoard();
                }, 100);
            }
        }

        function getBestMove(color) {
            let allMoves = [];
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (board[r][c] && board[r][c].color === color) {
                        const moves = getValidMoves(r, c);
                        moves.forEach(m => allMoves.push({ from: { r, c }, to: m }));
                    }
                }
            }
            if (allMoves.length === 0) return null;
            
            allMoves.forEach(move => {
                let score = 0;
                const target = board[move.to.r][move.to.c];
                if (target) score += PIECE_VALUES[target.type] * 10;
                if (isSquareAttacked(move.to.r, move.to.c, color)) score -= PIECE_VALUES[board[move.from.r][move.from.c].type];
                if (move.to.r >= 2 && move.to.r <= 5 && move.to.c >= 2 && move.to.c <= 5) score += 2;
                move.score = score;
            });

            allMoves.sort((a, b) => b.score - a.score);
            const topMoves = allMoves.filter(m => m.score === allMoves[0].score);
            return topMoves[Math.floor(Math.random() * topMoves.length)];
        }

        function isSquareAttacked(r, c, myColor) {
            const opp = myColor === 'white' ? 'black' : 'white';
            for (let ir = 0; ir < 8; ir++) {
                for (let ic = 0; ic < 8; ic++) {
                    if (board[ir][ic] && board[ir][ic].color === opp) {
                        if (getValidMoves(ir, ic, true).some(m => m.r === r && m.c === c)) return true;
                    }
                }
            }
            return false;
        }

        function addToHistoryLog(piece, fR, fC, tR, tC, captured) {
            const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
            const moveNum = Math.ceil(moveHistory.length / 2);
            const moveText = `${piece.type === 'pawn' ? '' : piece.type.charAt(0).toUpperCase()}${captured ? 'x' : ''}${files[tC]}${8 - tR}`;
            if (piece.color === 'white') {
                const item = document.createElement('div');
                item.className = 'history-item p-2 flex justify-between';
                item.innerHTML = `<span class="text-slate-500 w-8">${moveNum}.</span><span class="flex-1 font-bold text-white">${moveText}</span><span class="flex-1 text-slate-400" id="black-move-${moveNum}">...</span>`;
                historyLog.appendChild(item);
            } else {
                const span = document.getElementById(`black-move-${moveNum}`);
                if (span) { span.innerText = moveText; span.className = 'flex-1 font-bold text-white'; }
            }
            historyLog.scrollTop = historyLog.scrollHeight;
        }

        function wouldResultInCheck(fR, fC, tR, tC, color) {
            const p = board[fR][fC], t = board[tR][tC];
            board[tR][tC] = p; board[fR][fC] = null;
            const check = isKingInCheck(color);
            board[fR][fC] = p; board[tR][tC] = t;
            return check;
        }

        function showVictory(winner) {
            if (gameMode === 'cvc') {
                renderBoard();
                setTimeout(resetGameInternal, 3000);
                return;
            }
            winnerText.innerText = `${winner.toUpperCase()} WINS!`;
            victoryModal.classList.remove('hidden');
        }

        resetBtn.onclick = () => confirm("Restart game?") && resetGameInternal();
        undoBtn.onclick = () => {
            if (moveHistory.length === 0 || isThinking) return;
            const steps = (gameMode === 'pvp') ? 1 : 2;
            for(let i=0; i<steps; i++) {
                if (moveHistory.length === 0) break;
                const last = moveHistory.pop();
                board[last.from.r][last.from.c] = last.piece;
                board[last.from.r][last.from.c].moved = last.prevMoved;
                board[last.to.r][last.to.c] = last.captured;
                if (last.captured) captured[last.piece.color].pop();
                turn = last.piece.color;
            }
            historyLog.innerHTML = '';
            renderBoard();
        };

        createBoard();
        renderBoard();
        if (gameMode === 'cvc') setTimeout(handleAITurn, 1000);

    </script>
</body>
</html>

