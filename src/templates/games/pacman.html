<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pac-Man Engine - Turbo Edition</title>
    <style>
        :root {
            --bg-color: #050505;
            --wall-color: #00ffcc;
            --pacman-color: #ffff00;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
        }

        body, html {
            width: 100%;
            height: 100%;
            background-color: var(--bg-color);
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Segoe UI', sans-serif;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: #000;
        }

        #pac-canvas {
            display: block;
            background: transparent;
        }

        #menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 1);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .start-btn {
            background: transparent;
            color: var(--wall-color);
            border: 1px solid rgba(0, 255, 204, 0.3);
            padding: 20px 50px;
            font-size: 12px;
            letter-spacing: 12px;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.6s cubic-bezier(0.16, 1, 0.3, 1);
            outline: none;
        }

        .start-btn:hover {
            border-color: var(--wall-color);
            letter-spacing: 20px;
            background: var(--wall-color);
            color: #000;
            box-shadow: 0 0 30px rgba(0, 255, 204, 0.5);
        }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="pac-canvas"></canvas>
        <div id="menu">
            <button id="start-btn" class="start-btn">Initiate Turbo Engine</button>
        </div>
    </div>

    <script>
        (function() {
            const canvas = document.getElementById('pac-canvas');
            const ctx = canvas.getContext('2d');
            const menu = document.getElementById('menu');
            const startBtn = document.getElementById('start-btn');
            
            let TILE_SIZE = 30;
            let mapW, mapH;
            let map = [];
            
            let gameOver = true;
            let isDying = false;
            let deathProgress = 0;

            // Speed set to Turbo levels
            const PACMAN_SPEED = 0.35; 
            const GHOST_SPEED = 0.18;

            class Entity {
                constructor(x, y, color, type = 'ghost') {
                    this.x = x;
                    this.y = y;
                    this.targetX = x;
                    this.targetY = y;
                    this.color = color;
                    this.dir = {x: 0, y: 0};
                    this.progress = 0;
                    this.type = type;
                    this.personality = 0; 
                }

                getLerpPos() {
                    return {
                        x: this.x + (this.targetX - this.x) * this.progress,
                        y: this.y + (this.targetY - this.y) * this.progress
                    };
                }
            }

            let pacman;
            let ghosts = [];
            const GHOST_DATA = [
                { color: '#ff2222', personality: 0 },
                { color: '#ff88ff', personality: 1 },
                { color: '#00ffff', personality: 3 },
                { color: '#ffbb33', personality: 2 }
            ];

            function generateMap() {
                mapW = Math.max(13, Math.floor(window.innerWidth / TILE_SIZE));
                mapH = Math.max(13, Math.floor(window.innerHeight / TILE_SIZE));
                if (mapW % 2 === 0) mapW--;
                if (mapH % 2 === 0) mapH--;

                map = [];
                for (let y = 0; y < mapH; y++) {
                    map[y] = [];
                    for (let x = 0; x < mapW; x++) {
                        if (x === 0 || y === 0 || x === mapW - 1 || y === mapH - 1) {
                            map[y][x] = 1; 
                        } else if (x % 2 === 0 && y % 2 === 0) {
                            map[y][x] = 1;
                        } else {
                            map[y][x] = Math.random() > 0.88 ? 1 : 2;
                        }
                    }
                }
                for(let i=1; i<4; i++) {
                    for(let j=1; j<4; j++) {
                        if (map[i]) map[i][j] = (i===1 && j===1) ? 0 : 2;
                    }
                }
                if (map[mapH-2]) map[mapH-2][mapW-2] = 0;
            }

            function resize() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                TILE_SIZE = Math.min(canvas.width / 18, canvas.height / 18, 32);
                generateMap();
                if(!gameOver) initEntities();
            }

            window.addEventListener('resize', resize);

            function getPacmanNextDir() {
                const queue = [[pacman.targetX, pacman.targetY, []]];
                const visited = new Set([`${pacman.targetX},${pacman.targetY}`]);

                while (queue.length > 0) {
                    const [cx, cy, path] = queue.shift();
                    if (map[cy] && map[cy][cx] === 2) return path[0] || {x:0, y:0};

                    const dirs = [{x: 1, y: 0}, {x: -1, y: 0}, {x: 0, y: 1}, {x: 0, y: -1}];
                    for (let d of dirs) {
                        const nx = cx + d.x, ny = cy + d.y;
                        if (map[ny] && map[ny][nx] !== 1 && !visited.has(`${nx},${ny}`)) {
                            visited.add(`${nx},${ny}`);
                            queue.push([nx, ny, [...path, d]]);
                        }
                    }
                }
                return {x: 0, y: 0};
            }

            function updateGhost(g) {
                const dirs = [{x: 1, y: 0}, {x: -1, y: 0}, {x: 0, y: 1}, {x: 0, y: -1}];
                const possibleDirs = dirs.filter(d => {
                    const nx = g.targetX + d.x, ny = g.targetY + d.y;
                    return map[ny] && map[ny][nx] !== 1;
                });
                let choices = possibleDirs.filter(d => !(d.x === -g.dir.x && d.y === -g.dir.y));
                if (choices.length === 0) choices = possibleDirs;

                let tx = pacman.targetX, ty = pacman.targetY;
                if (g.personality === 0) {
                    if (Math.floor(Date.now() / 6000) % 2 === 0) { tx = mapW-2; ty = 1; }
                } else if (g.personality === 1) {
                    tx += pacman.dir.x * 4; ty += pacman.dir.y * 4;
                } else if (g.personality === 2) {
                    if(Math.random() > 0.8) { tx = Math.floor(Math.random()*mapW); ty = Math.floor(Math.random()*mapH); }
                } else if (g.personality === 3) {
                    const corners = [{x:1, y:1}, {x:mapW-2, y:1}, {x:1, y:mapH-2}, {x:mapW-2, y:mapH-2}];
                    const target = corners[Math.floor(Date.now() / 3000) % 4];
                    tx = target.x; ty = target.y;
                }

                const bestDir = choices.sort((a, b) => {
                    const distA = Math.hypot(tx - (g.targetX + a.x), ty - (g.targetY + a.y));
                    const distB = Math.hypot(tx - (g.targetX + b.x), ty - (g.targetY + b.y));
                    return distA - distB;
                })[0];

                if (bestDir) { g.dir = bestDir; g.targetX += bestDir.x; g.targetY += bestDir.y; }
            }

            function draw() {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const offsetX = (canvas.width - mapW * TILE_SIZE) / 2;
                const offsetY = (canvas.height - mapH * TILE_SIZE) / 2;

                for (let y = 0; y < mapH; y++) {
                    for (let x = 0; x < mapW; x++) {
                        const tx = offsetX + x * TILE_SIZE;
                        const ty = offsetY + y * TILE_SIZE;
                        if (map[y] && map[y][x] === 1) {
                            ctx.strokeStyle = '#00ffcc';
                            ctx.shadowBlur = 8;
                            ctx.shadowColor = '#00ffcc';
                            ctx.strokeRect(tx + 4, ty + 4, TILE_SIZE - 8, TILE_SIZE - 8);
                            ctx.shadowBlur = 0;
                        } else if (map[y] && map[y][x] === 2) {
                            ctx.fillStyle = '#ffffff';
                            ctx.beginPath();
                            ctx.arc(tx + TILE_SIZE/2, ty + TILE_SIZE/2, 2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }

                const pPos = pacman.getLerpPos();
                const px = offsetX + pPos.x * TILE_SIZE + TILE_SIZE/2;
                const py = offsetY + pPos.y * TILE_SIZE + TILE_SIZE/2;
                
                if (isDying) {
                    ctx.fillStyle = '#ffff00';
                    const radius = Math.max(0, (TILE_SIZE/2 - 2) * (1 - deathProgress));
                    ctx.beginPath();
                    ctx.arc(px, py, radius, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    const angle = Math.atan2(pacman.dir.y, pacman.dir.x);
                    const mouthOpen = Math.abs(Math.sin(Date.now() / 40)) * 0.6;
                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath();
                    ctx.moveTo(px, py);
                    ctx.arc(px, py, TILE_SIZE/2 - 2, angle + mouthOpen, angle + Math.PI * 2 - mouthOpen);
                    ctx.fill();
                }

                ghosts.forEach(g => {
                    const gPos = g.getLerpPos();
                    const gx = offsetX + gPos.x * TILE_SIZE + TILE_SIZE/2;
                    const gy = offsetY + gPos.y * TILE_SIZE + TILE_SIZE/2;
                    const r = TILE_SIZE/2 - 2;

                    ctx.globalAlpha = isDying ? 0.3 : 1.0;
                    ctx.fillStyle = g.color;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = g.color;
                    ctx.beginPath();
                    ctx.arc(gx, gy, r, Math.PI, 0);
                    ctx.lineTo(gx + r, gy + r);
                    for(let i=0; i<=2; i++) {
                        const wave = isDying ? 0 : Math.sin((Date.now() / 35) + i) * 3;
                        ctx.lineTo(gx + r - (i * r * 2/2), gy + r + wave);
                    }
                    ctx.lineTo(gx - r, gy + r);
                    ctx.fill();
                    ctx.shadowBlur = 0;

                    const eyeOffset = 1.5;
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(gx - r/2.5, gy - r/4, r/3, 0, Math.PI * 2);
                    ctx.arc(gx + r/2.5, gy - r/4, r/3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(gx - r/2.5 + g.dir.x * eyeOffset, gy - r/4 + g.dir.y * eyeOffset, r/6, 0, Math.PI * 2);
                    ctx.arc(gx + r/2.5 + g.dir.x * eyeOffset, gy - r/4 + g.dir.y * eyeOffset, r/6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                });
            }

            function triggerDeath() {
                if (isDying) return;
                isDying = true;
                deathProgress = 0;
            }

            function update() {
                if (gameOver) return;

                if (isDying) {
                    deathProgress += 0.05;
                    if (deathProgress >= 1) {
                        isDying = false;
                        initEntities();
                    }
                } else {
                    pacman.progress += PACMAN_SPEED;
                    ghosts.forEach(g => g.progress += GHOST_SPEED);

                    if (pacman.progress >= 1) {
                        pacman.x = pacman.targetX;
                        pacman.y = pacman.targetY;
                        pacman.progress = 0;
                        if (map[pacman.y] && map[pacman.y][pacman.x] === 2) map[pacman.y][pacman.x] = 0;
                        const next = getPacmanNextDir();
                        if (map[pacman.y + next.y] && map[pacman.y + next.y][pacman.x + next.x] !== 1) {
                            pacman.dir = next;
                            pacman.targetX += next.x;
                            pacman.targetY += next.y;
                        }
                    }

                    ghosts.forEach(g => {
                        if (g.progress >= 1) {
                            g.x = g.targetX; g.y = g.targetY; g.progress = 0;
                            updateGhost(g);
                        }
                        const pPos = pacman.getLerpPos();
                        const gPos = g.getLerpPos();
                        if (Math.hypot(pPos.x - gPos.x, pPos.y - gPos.y) < 0.5) {
                            triggerDeath();
                        }
                    });

                    if (!map.flat().includes(2)) generateMap();
                }

                draw();
                requestAnimationFrame(update);
            }

            function initEntities() {
                pacman = new Entity(1, 1, '#ffff00', 'pacman');
                pacman.dir = {x: 1, y: 0};
                pacman.targetX = 2;
                ghosts = GHOST_DATA.map((data, i) => {
                    const g = new Entity(mapW - 2, mapH - 2, data.color);
                    g.personality = data.personality;
                    g.y -= i; g.targetY -= i;
                    return g;
                });
                isDying = false;
            }

            startBtn.addEventListener('click', () => {
                menu.style.display = 'none';
                generateMap();
                initEntities();
                gameOver = false;
                requestAnimationFrame(update);
            });

            resize();
        })();
    </script>
</body>
</html>

